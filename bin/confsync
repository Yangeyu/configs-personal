#!/bin/bash

# ConfSync - 配置同步工具 v1.0.0
# 跨平台配置文件管理和Git同步工具

set -e

# =============================================================================
# 全局配置
# =============================================================================

readonly CS_DIR="$HOME/.confsync"
readonly CONFIG_DIR="$CS_DIR/configs"
readonly DATA_DIR="$CS_DIR/data"
readonly INDEX_FILE="$DATA_DIR/index.json"

# 颜色定义
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

# =============================================================================
# 工具函数
# =============================================================================

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_header() { echo -e "${CYAN}=== $1 ===${NC}"; }

# 生成唯一ID
gen_id() { echo "cfg_$(date +%s)_$(shuf -i 1000-9999 -n 1)"; }

# 获取文件信息
get_file_info() {
    local file="$1"
    local size hash

    case "$(uname)" in
        Darwin*) size=$(stat -f%z "$file" 2>/dev/null || echo "0") ;;
        *) size=$(stat -c%s "$file" 2>/dev/null || echo "0") ;;
    esac

    hash=$(shasum -a 256 "$file" 2>/dev/null | cut -d' ' -f1 || echo "")
    echo "$size|$hash"
}

# 标准化目录路径
normalize_dir() {
    local path="$1"
    if [[ "$path" == "$HOME"* ]]; then
        echo "~${path#$HOME}"
    else
        echo "$path"
    fi
}

# 展开目录路径
expand_dir() {
    local path="$1"
    if [[ "$path" == "~"* ]]; then
        echo "$HOME${path:1}"
    else
        echo "$path"
    fi
}

# =============================================================================
# 核心数据管理
# =============================================================================

# 初始化索引
init_index() {
    if [[ -f "$INDEX_FILE" ]]; then
        return
    fi

    mkdir -p "$DATA_DIR"
    cat > "$INDEX_FILE" << 'EOF'
{
  "version": "1.0.0",
  "configs": [],
  "categories": {
    "shell": "Shell配置文件",
    "editor": "编辑器配置",
    "system": "系统配置",
    "app": "应用程序配置",
    "network": "网络配置",
    "other": "其他配置"
  },
  "metadata": {
    "created_at": "",
    "last_sync": "",
    "total_configs": 0
  }
}
EOF

    jq --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
       '.metadata.created_at = $timestamp' "$INDEX_FILE" > "$INDEX_FILE.tmp" && \
    mv "$INDEX_FILE.tmp" "$INDEX_FILE"
}

# 检查依赖
check_deps() {
    local missing=()
    for cmd in git curl jq; do
        command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "缺少依赖: ${missing[*]}"
        log_info "安装建议:"
        echo "  macOS: brew install ${missing[*]}"
        echo "  Ubuntu: apt-get install ${missing[*]}"
        echo "  CentOS: yum install ${missing[*]}"
        exit 1
    fi
}

# =============================================================================
# 配置管理功能
# =============================================================================

# 添加配置
add_config() {
    local file_path="$1"
    local config_name="$2"
    local category="$3"
    local description="$4"

    if [[ -z "$file_path" ]]; then
        log_error "请指定配置文件路径"
        exit 1
    fi

    if [[ ! -f "$file_path" ]]; then
        log_error "配置文件不存在: $file_path"
        exit 1
    fi

    # 默认名称
    if [[ -z "$config_name" ]]; then
        config_name=$(basename "$file_path")
    fi

    # 自动推断类别
    if [[ -z "$category" ]]; then
        case "$config_name" in
            *.zshrc|*.bashrc|*.profile) category="shell" ;;
            *.vimrc|*.emacs) category="editor" ;;
            *.ssh/config|gitconfig) category="system" ;;
            *) category="other" ;;
        esac
    fi

    init_index

    # 检查重复
    if jq -e ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" >/dev/null; then
        log_error "配置 '$config_name' 已存在"
        exit 1
    fi

    # 复制文件
    local dest_file="$CONFIG_DIR/$config_name"
    mkdir -p "$CONFIG_DIR"
    if ! cp "$file_path" "$dest_file"; then
        log_error "文件复制失败"
        exit 1
    fi

    # 获取文件信息
    local abs_path=$(realpath "$file_path")
    local file_info=$(get_file_info "$file_path")
    local size=$(echo "$file_info" | cut -d'|' -f1)
    local hash=$(echo "$file_info" | cut -d'|' -f2)
    local dir_path=$(normalize_dir "$(dirname "$abs_path")")
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local config_id=$(gen_id)

    # 更新索引
    jq --arg id "$config_id" --arg name "$config_name" --arg path "$abs_path" \
       --arg category "$category" --arg desc "$description" \
       --arg timestamp "$timestamp" --arg size "$size" \
       --arg hash "$hash" --arg dir_path "$dir_path" \
       '.configs += [{
         "id": $id, "name": $name, "original_path": $path,
         "directory": $dir_path, "category": $category,
         "description": $desc, "added_at": $timestamp,
         "last_updated": $timestamp, "size": ($size | tonumber),
         "hash": $hash, "version": "1"
       }] | .metadata.total_configs = (.configs | length)' \
       "$INDEX_FILE" > "$INDEX_FILE.tmp" && mv "$INDEX_FILE.tmp" "$INDEX_FILE"

    log_success "配置 '$config_name' 添加成功"
    log_info "ID: $config_id | 类别: $category | 原路径: $abs_path"
}

# 列出配置
list_configs() {
    local filter_category="$1"
    init_index

    local filter=""
    if [[ -n "$filter_category" ]]; then
        filter=" | select(.category == \"$filter_category\")"
    fi

    local configs=$(jq -r ".configs[]$filter | \"\(.name)|\(.category)|\(.description // \"无描述\")|\(.added_at)|\(.directory // \"未记录\")\"" "$INDEX_FILE" 2>/dev/null)

    if [[ -z "$configs" ]]; then
        if [[ -n "$filter_category" ]]; then
            log_warning "类别 '$filter_category' 下没有配置"
        else
            log_warning "没有找到任何配置"
        fi
        return
    fi

    echo
    log_header "配置文件列表"
    printf "%-20s %-10s %-30s %-25s %-15s\n" "名称" "类别" "描述" "目录" "添加时间"
    printf "%-20s %-10s %-30s %-25s %-15s\n" "----" "----" "----" "----" "--------"

    echo "$configs" | while IFS='|' read -r name category desc added_at directory; do
        printf "%-20s %-10s %-30s %-25s %-15s\n" \
            "$(echo "$name" | cut -c1-20)" \
            "$(echo "$category" | cut -c1-10)" \
            "$(echo "$desc" | cut -c1-30)" \
            "$(echo "$directory" | cut -c1-25)" \
            "$(echo "$added_at" | cut -c1-10)"
    done

    local total=$(jq '.configs | length' "$INDEX_FILE" 2>/dev/null || echo "0")
    local filtered=$(echo "$configs" | wc -l | tr -d ' ')
    echo && log_info "显示: $filtered / $total 个配置"
}

# 显示配置详情
show_config() {
    local config_name="$1"
    if [[ -z "$config_name" ]]; then
        log_error "请指定配置名称"
        exit 1
    fi

    init_index
    local config_info=$(jq -r ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" 2>/dev/null)

    if [[ -z "$config_info" ]]; then
        log_error "配置 '$config_name' 不存在"
        exit 1
    fi

    log_header "配置详细信息"
    echo "$config_info" | jq -r '
        "名称: " + .name +
        "\nID: " + .id +
        "\n类别: " + .category +
        "\n描述: " + (.description // "无描述") +
        "\n原始路径: " + .original_path +
        "\n存储目录: " + (.directory // "未记录") +
        "\n添加时间: " + .added_at +
        "\n最后更新: " + .last_updated +
        "\n文件大小: " + (.size | tostring) + " 字节" +
        "\n文件哈希: " + .hash +
        "\n版本: " + (.version // "1")'

    echo
    local config_file="$CONFIG_DIR/$config_name"
    if [[ -f "$config_file" ]]; then
        log_header "配置文件内容预览"
        echo "--- 前20行内容 ---"
        head -20 "$config_file"
        echo "--- 内容预览结束 ---"
        echo && log_info "完整文件路径: $config_file"
    else
        log_warning "配置文件不存在: $config_file"
    fi
}

# =============================================================================
# 还原功能
# =============================================================================

# 智能还原
smart_restore() {
    local config_name="$1"
    local target_path="$2"
    local to_dir="$3"
    local force="$4"
    local config_file="$CONFIG_DIR/$config_name"

    if [[ ! -f "$config_file" ]]; then
        log_error "配置文件不存在: $config_file"
        exit 1
    fi

    local config_info=$(jq -r ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" 2>/dev/null)
    local final_path="$target_path"

    # 确定目标路径
    if [[ -n "$to_dir" ]]; then
        final_path="$to_dir/$config_name"
        mkdir -p "$to_dir"
    elif [[ -n "$target_path" ]]; then
        final_path="$target_path"
        mkdir -p "$(dirname "$target_path")"
    else
        # 智能还原
        local stored_dir=$(echo "$config_info" | jq -r '.directory // ""')
        if [[ -n "$stored_dir" ]]; then
            local resolved_dir=$(expand_dir "$stored_dir")
            final_path="$resolved_dir/$config_name"
            log_info "智能还原到存储目录: $resolved_dir"
            mkdir -p "$resolved_dir"
        else
            final_path=$(echo "$config_info" | jq -r '.original_path')
            log_info "未找到存储目录，使用原始路径"
        fi
    fi

    # 处理文件冲突
    if [[ -f "$final_path" && "$force" != "true" ]]; then
        log_warning "目标文件已存在: $final_path"
        read -p "是否覆盖? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "操作已取消"
            return
        fi

        local backup="$final_path.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$final_path" "$backup"
        log_info "原文件已备份到: $backup"
    fi

    # 执行还原
    mkdir -p "$(dirname "$final_path")"
    cp "$config_file" "$final_path"
    log_success "配置 '$config_name' 已还原到: $final_path"
}

# 还原配置
restore_config() {
    local config_name="$1"
    local target_path="$2"
    local to_dir=""
    local force=false

    # 解析参数
    for arg in "${@:2}"; do
        case $arg in
            --to-dir=*) to_dir="${arg#*=}" ;;
            --force) force=true ;;
        esac
    done

    if [[ -z "$config_name" ]]; then
        log_error "请指定配置名称"
        exit 1
    fi

    init_index

    # 检查配置存在
    if ! jq -e ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" >/dev/null; then
        log_error "配置 '$config_name' 不存在"
        exit 1
    fi

    smart_restore "$config_name" "$target_path" "$to_dir" "$force"
}

# =============================================================================
# Git 同步功能
# =============================================================================

# 初始化Git仓库
init_repo() {
    local repo_url="$1"

    cd "$CS_DIR"

    if [[ ! -d ".git" ]]; then
        log_info "初始化Git仓库..."
        git init -q
        git config user.name "ConfSync"
        git config user.email "confsync@local"
    fi

    if [[ -n "$repo_url" ]]; then
        if git remote get-url origin >/dev/null 2>&1; then
            git remote set-url origin "$repo_url"
        else
            git remote add origin "$repo_url"
        fi
        log_info "远程仓库设置完成: $repo_url"
    fi

    # 创建.gitignore
    cat > .gitignore << 'EOF'
# 忽略临时文件
*.tmp
*.bak
*.log
.DS_Store
EOF

    # 初始提交
    if git status --porcelain >/dev/null; then
        git add .
        git commit -m "Initial commit - ConfSync setup" -q
    fi

    # 推送远程
    if [[ -n "$repo_url" ]]; then
        log_info "推送到远程仓库..."
        git push -u origin main 2>/dev/null || git push -u origin master 2>/dev/null || \
            log_warning "无法推送到远程仓库，请检查网络和权限"
    fi

    log_success "仓库初始化完成"
}

# 同步配置
sync_configs() {
    init_index

    if [[ ! -d "$CS_DIR/.git" ]]; then
        log_error "请先初始化远程仓库: confsync init <仓库地址>"
        exit 1
    fi

    cd "$CS_DIR"

    # 检查更改
    if ! git status --porcelain >/dev/null; then
        log_info "没有需要同步的更改"
        return
    fi

    git add .
    git commit -m "Update configs - $(date '+%Y-%m-%d %H:%M:%S')" -q

    # 更新同步时间
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    jq --arg timestamp "$timestamp" '.metadata.last_sync = $timestamp' \
       "$INDEX_FILE" > "$INDEX_FILE.tmp" && mv "$INDEX_FILE.tmp" "$INDEX_FILE"

    # 推送远程
    if git remote get-url origin >/dev/null 2>&1; then
        log_info "推送到远程仓库..."
        if git push origin main 2>/dev/null || git push origin master 2>/dev/null; then
            log_success "配置已同步到远程仓库"
        else
            log_error "推送失败，请检查网络和权限"
            exit 1
        fi
    else
        log_success "配置已本地提交"
    fi
}

# 拉取配置
pull_configs() {
    init_index

    if [[ ! -d "$CS_DIR/.git" ]]; then
        log_error "请先初始化远程仓库: confsync init <仓库地址>"
        exit 1
    fi

    cd "$CS_DIR"
    if ! git remote get-url origin >/dev/null 2>&1; then
        log_error "没有设置远程仓库"
        exit 1
    fi

    log_info "从远程仓库拉取配置..."
    if git pull origin main 2>/dev/null || git pull origin master 2>/dev/null; then
        log_success "配置已从远程仓库拉取"
        local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        jq --arg timestamp "$timestamp" '.metadata.last_sync = $timestamp' \
           "$INDEX_FILE" > "$INDEX_FILE.tmp" && mv "$INDEX_FILE.tmp" "$INDEX_FILE"
    else
        log_error "拉取失败，请检查网络连接"
        exit 1
    fi
}

# =============================================================================
# 交互式模式
# =============================================================================

# 交互式还原
interactive_restore() {
    local config_name="$1"
    local stored_dir="$2"

    echo
    log_header "还原配置: $config_name"

    # 显示配置信息
    local config_info=$(jq -r ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" 2>/dev/null)
    if [[ -n "$config_info" ]]; then
        echo "配置信息:"
        echo "  类别: $(echo "$config_info" | jq -r '.category // "未知"')"
        echo "  描述: $(echo "$config_info" | jq -r '.description // "无描述"')"
        echo "  原始路径: $(echo "$config_info" | jq -r '.original_path // "未知"')"
        echo
    fi

    # 默认目录
    local default_dir=""
    if [[ -n "$stored_dir" && "$stored_dir" != "未记录" ]]; then
        default_dir=$(expand_dir "$stored_dir")
    fi

    echo "还原选项:"
    if [[ -n "$default_dir" ]]; then
        echo "  1. 智能还原到存储目录: $default_dir"
    fi
    echo "  $([[ -n "$default_dir" ]] && echo "2" || echo "1"). 还原到原始路径"
    echo "  $([[ -n "$default_dir" ]] && echo "3" || echo "2"). 指定还原目录"
    echo "  $([[ -n "$default_dir" ]] && echo "4" || echo "3"). 指定还原文件路径"
    echo

    local max_choice=$([[ -n "$default_dir" ]] && echo "4" || echo "3")
    read -p "请选择还原方式 (1-$max_choice): " choice

    case "$choice" in
        "1")
            if [[ -n "$default_dir" ]]; then
                read -p "目标目录 [$default_dir]: " target_dir
                smart_restore "$config_name" "" "${target_dir:-$default_dir}"
            else
                smart_restore "$config_name"
            fi
            ;;
        "2")
            if [[ -n "$default_dir" ]]; then
                smart_restore "$config_name"
            else
                smart_restore "$config_name"
            fi
            ;;
        "3"|"4")
            local option=$([[ -n "$default_dir" ]] && echo "$choice" || echo "$((choice-1))")
            if [[ "$option" == "3" ]]; then
                read -p "请输入目标目录: " target_dir
                if [[ -n "$target_dir" ]]; then
                    smart_restore "$config_name" "" "$target_dir"
                fi
            else
                read -p "请输入目标文件路径: " target_path
                if [[ -n "$target_path" ]]; then
                    smart_restore "$config_name" "$target_path"
                fi
            fi
            ;;
        *)
            log_error "无效的选择"
            ;;
    esac
}

# 交互式主循环
interactive_mode() {
    init_index

    if [[ ! -f "$INDEX_FILE" ]]; then
        log_warning "没有找到任何配置文件"
        log_info "请先添加配置文件: confsync add <文件路径>"
        return
    fi

    while true; do
        echo
        log_header "ConfSync 交互式配置管理"

        # 获取配置列表
        local configs=$(jq -r '.configs[] | "\(.name)|\(.category)|\(.directory // "未记录")|\(.description // "无描述")"' "$INDEX_FILE" 2>/dev/null)

        if [[ -z "$configs" ]]; then
            log_warning "没有找到任何配置文件"
            return
        fi

        # 显示配置列表
        echo
        printf "%-3s %-20s %-12s %-25s %-30s\n" "编号" "名称" "类别" "目录" "描述"
        printf "%-3s %-20s %-12s %-25s %-30s\n" "---" "----" "----" "----" "----"

        local count=1
        echo "$configs" | while IFS='|' read -r name category directory description; do
            printf "%-3d %-20s %-12s %-25s %-30s\n" "$count" \
                "$(echo "$name" | cut -c1-20)" \
                "$(echo "$category" | cut -c1-12)" \
                "$(echo "$directory" | cut -c1-25)" \
                "$(echo "$description" | cut -c1-30)"
            ((count++))
        done

        echo
        echo "可用操作:"
        echo "  1-$((${count}-1))  - 选择配置文件进行还原"
        echo "  s            - 同步到远程仓库"
        echo "  p            - 从远程仓库拉取"
        echo "  l            - 重新列出配置"
        echo "  q            - 退出交互模式"
        echo

        read -p "请选择操作: " choice

        case "$choice" in
            [1-9]|[1-9][0-9])
                if [[ "$choice" -ge 1 && "$choice" -lt "$count" ]]; then
                    local selected_name=$(echo "$configs" | sed -n "${choice}p" | cut -d'|' -f1)
                    local selected_dir=$(echo "$configs" | sed -n "${choice}p" | cut -d'|' -f3)
                    if [[ -n "$selected_name" ]]; then
                        interactive_restore "$selected_name" "$selected_dir"
                    else
                        log_error "无法获取配置信息"
                    fi
                else
                    log_error "无效的选择，请输入 1-$((${count}-1)) 之间的数字"
                fi
                ;;
            "s"|"S")
                log_info "同步到远程仓库..."
                sync_configs
                ;;
            "p"|"P")
                log_info "从远程仓库拉取..."
                pull_configs
                ;;
            "l"|"L")
                continue
                ;;
            "q"|"Q")
                log_info "退出交互模式"
                break
                ;;
            *)
                log_error "无效的选择: $choice"
                ;;
        esac

        echo
        read -p "按回车键继续..."
    done
}

# =============================================================================
# 其他功能
# =============================================================================

# 移除配置
remove_config() {
    local config_name="$1"
    if [[ -z "$config_name" ]]; then
        log_error "请指定配置名称"
        exit 1
    fi

    init_index
    if ! jq -e ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" >/dev/null; then
        log_error "配置 '$config_name' 不存在"
        exit 1
    fi

    read -p "确定要移除配置 '$config_name' 吗? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "操作已取消"
        return
    fi

    jq "(.configs |= map(select(.name != \"$config_name\"))) | .metadata.total_configs = (.configs | length)" \
       "$INDEX_FILE" > "$INDEX_FILE.tmp" && mv "$INDEX_FILE.tmp" "$INDEX_FILE"

    local config_file="$CONFIG_DIR/$config_name"
    if [[ -f "$config_file" ]]; then
        rm "$config_file"
        log_success "配置 '$config_name' 已移除"
    fi
}

# 备份配置
backup_config() {
    local config_name="$1"

    if [[ -n "$config_name" ]]; then
        # 备份指定配置
        init_index
        local config_info=$(jq -r ".configs[] | select(.name == \"$config_name\")" "$INDEX_FILE" 2>/dev/null)
        if [[ -z "$config_info" ]]; then
            log_error "配置 '$config_name' 不存在"
            exit 1
        fi

        local original_path=$(echo "$config_info" | jq -r '.original_path')
        if [[ ! -f "$original_path" ]]; then
            log_warning "原始配置文件不存在: $original_path"
            return
        fi

        local backup="$original_path.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$original_path" "$backup"
        log_success "配置 '$config_name' 已备份到: $backup"
    else
        # 备份所有配置
        log_info "备份所有现有配置..."
        init_index

        jq -r '.configs[].original_path' "$INDEX_FILE" 2>/dev/null | while read -r path; do
            if [[ -f "$path" ]]; then
                local backup="$path.backup.$(date +%Y%m%d_%H%M%S)"
                cp "$path" "$backup"
                log_info "已备份: $path -> $backup"
            fi
        done

        log_success "配置备份完成"
    fi
}

# 显示状态
show_status() {
    echo
    log_header "ConfSync 状态"

    echo "安装目录: $CS_DIR"
    echo "配置目录: $CONFIG_DIR"
    echo "数据目录: $DATA_DIR"

    # Git状态
    if [[ -d "$CS_DIR/.git" ]]; then
        cd "$CS_DIR"
        echo "Git仓库: 已初始化"
        if git remote get-url origin >/dev/null 2>&1; then
            echo "远程仓库: $(git remote get-url origin)"
        else
            echo "远程仓库: 未设置"
        fi

        if git status --porcelain >/dev/null; then
            echo "Git状态: 有未提交的更改"
        else
            echo "Git状态: 干净"
        fi

        echo "当前分支: $(git branch --show-current)"
    else
        echo "git仓库: 未初始化"
    fi

    # 配置统计
    if [[ -f "$INDEX_FILE" ]]; then
        local count=$(jq '.configs | length' "$INDEX_FILE" 2>/dev/null || echo "0")
        echo "管理的配置数量: $count"

        local last_sync=$(jq -r '.metadata.last_sync // "从未同步"' "$INDEX_FILE")
        if [[ "$last_sync" != "从未同步" ]]; then
            echo "最后同步时间: $last_sync"
        fi
    else
        echo "管理的配置数量: 0"
    fi

    echo
}

# 显示帮助
show_help() {
    echo "ConfSync v1.0.0 - 配置同步工具"
    echo
    echo "用法: confsync <命令> [参数]"
    echo
    echo "命令:"
    echo "  add <文件路径> [名称] [--category=类别] [--desc=描述]"
    echo "                             添加配置文件到管理（自动记录目录结构）"
    echo "  list [--category=类别]     列出所有管理的配置文件"
    echo "  show <名称>                显示配置文件详细信息"
    echo "  sync                       同步配置到远程仓库"
    echo "  pull                       从远程仓库拉取配置"
    echo "  restore <名称> [目标路径]   还原指定配置文件（智能还原到原目录）"
    echo "  restore <名称> --to-dir <目录>  还原配置文件到指定目录"
    echo "  init [仓库地址]             初始化或设置远程仓库"
    echo "  status                     显示当前状态"
    echo "  remove <名称>              移除配置文件管理"
    echo "  backup [名称]              备份现有配置文件"
    echo "  -i, --interactive          交互式配置管理（选择并还原配置）"
    echo
    echo "选项:"
    echo "  --category=类别            配置分类 (如: shell, editor, system)"
    echo "  --desc=描述               配置描述信息"
    echo "  --to-dir=目录             还原到指定目录"
    echo "  --force                   强制覆盖现有文件"
    echo
    echo "示例:"
    echo "  confsync add ~/.zshrc zsh-config --category=shell"
    echo "  confsync -i"
    echo "  confsync restore zsh-config"
}

# =============================================================================
# 主函数
# =============================================================================

main() {
    mkdir -p "$CONFIG_DIR" "$DATA_DIR"
    check_deps

    case "${1:-}" in
        "add")
            # 解析add命令参数
            local file_path="$2"
            local config_name="$3"
            local category=""
            local description=""
            for arg in "${@:4}"; do
                case $arg in
                    --category=*) category="${arg#*=}" ;;
                    --desc=*) description="${arg#*=}" ;;
                esac
            done
            add_config "$file_path" "$config_name" "$category" "$description"
            ;;
        "list")
            local filter_category=""
            for arg in "${@:2}"; do
                case $arg in
                    --category=*) filter_category="${arg#*=}" ;;
                esac
            done
            list_configs "$filter_category"
            ;;
        "show")
            show_config "$2"
            ;;
        "sync")
            sync_configs
            ;;
        "pull")
            pull_configs
            ;;
        "restore")
            restore_config "$2" "${@:3}"
            ;;
        "init")
            init_repo "$2"
            ;;
        "status")
            show_status
            ;;
        "remove")
            remove_config "$2"
            ;;
        "backup")
            backup_config "$2"
            ;;
        "-i"|"--interactive")
            interactive_mode
            ;;
        "help"|"--help"|"-h"|"")
            show_help
            ;;
        *)
            log_error "未知命令: $1"
            show_help
            exit 1
            ;;
    esac
}

main "$@"